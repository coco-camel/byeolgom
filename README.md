# [별곰] 항해99 19기 5조 

주특기: Node.js, React

- **🌟 [FE GitHub 바로가기](https://github.com/BYEOL-GOM/FP-FRONT)**
- **🌟 [BE GitHub 바로가기](https://github.com/BYEOL-GOM/FP-BACK)** <br/>
- **🌟 [서비스 주소](https://byeolgom.com/login)**

---

# **⭐️별곰🐻**

![Frame_4](https://github.com/BYEOL-GOM/FP-FRONT/assets/157693710/31abc8ef-8002-4760-a916-5ff6bf73f8aa)

<aside>
💡 말할 수 없는 고민이 많은 현대인들을 위한 1:1 익명 고민공유 서비스

</aside>


---

## **🎤** 팀원 소개

| 이름 | 역할 | GitHub | email |
| --- | --- | --- | --- |
| 김준오 👑 | FE / 팀장 | https://github.com/coco-camel | anint3647@gmail.com  |
| 임채리 | FE / 서기, 디자인 | https://github.com/cherryl-dev | chaeliim75@gmail.com |
| 김기현 | FE / 프로젝트 발표 | https://github.com/Dustyspac | kim724265@gmail.com |
| 정재훈 | BE / 부팀장 | https://github.com/rosa1435 | 01083066699a@gmail.com  |
| 김우정 | BE / 총무 | https://github.com/friend-0228 | kwj2712@gmail.com |
| 박성희 | BE / 기술고문 | https://github.com/LetyPark | tkrhktyd@gmail.com |
| 정다은 | 디자이너 / 🎨 || danaray@naver.com |

---

## 🧬 서비스 아키텍쳐

![Group_72](https://github.com/BYEOL-GOM/FP-FRONT/assets/157693710/c129b50e-8469-4526-bc57-a839d3f4d754)

---

## **🌟** 주요 기능 소개

<details>
  
<summary>🖋️ 고민 & 답장 작성</summary>
    
![0_고민작성](https://github.com/BYEOL-GOM/FP-FRONT/assets/157693710/ae690d1d-8e7f-4c49-a039-ca8919696033)

  <aside>
    
  💡 메인 하단의 우주선 모양을 클릭
  
  </aside>
  
  <aside>
    
  🖋️ 내 고민을 작성
  
  > 페이지 상단 중앙의 로켓 클릭으로 로켓의 모양 지정 가능
  > 
  
  > 하단 색상변경 아이콘으로 보낼 때의 텍스트 색상 지정 가능
  > 
  </aside>
  
  <aside>
    
  👆 전송하기 버튼 클릭
  
  </aside>
  
  <aside>
    
  ✅ 고민 작성 성공!
  
  </aside>
    
</details>

<details>
  
<summary> 🚀 답례전송 & 1:1 채팅</summary>
    
![0_답례전송](https://github.com/BYEOL-GOM/FP-FRONT/assets/157693710/70725600-fc8a-45f6-ab31-f2a9a0d77bc3)

  <aside>
    
  💡 행성 주변의 우주선 클릭
  
  </aside>
  
  <aside>
    
  🖋️ 하단의 입력창 선택 후, 답변 작성
  
  </aside>
  
  <aside>
    
  👆 이때, 온 답변에 답례를 보내고 싶다면 하단의 답례 전송 버튼 선택
  
  > 나의 고민에서 시작된 우주선만 답례 전송 가능
  > 
  
  > 답례 전송 시, 1:1 채팅 요청을 원한다면 [ 답례와 함께 1:1 채팅 요청 ] 선택
  > 
  </aside>
  
  <aside>
  ✅ 답변 및 답례 전송 성공!
  
  </aside>
    
</details>

<details>
  
<summary>🪐 행성 스킨 상점</summary>
    
![0_상점](https://github.com/BYEOL-GOM/FP-FRONT/assets/157693710/8a8e4e44-f8a4-4f0d-a770-b5414ab7dfad)

  <aside>
    
  💡 메인의 상점 버튼 클릭
  
  </aside>
  
  <aside>
    
  👆 내가 가진 별(답례)의 갯수 확인 후, 구매하고 싶은 행성 종류 선택
  
  </aside>
  
  <aside>
    
  ✅ 조건이 만족한다면, 구매 성공!
  
  > 이때, 구매한 행성을 적용하고 싶다면 한 번 더 클릭해 행성 적용
  > 
  </aside>
    
</details>

<details>
  
<summary>🏆 랭킹</summary>
    
![0_랭킹](https://github.com/BYEOL-GOM/FP-FRONT/assets/157693710/4d00f927-2948-4440-a31d-b21b3d4e9732)

  
  <aside>
    
  💡 메인의 랭킹 아이콘 클릭
  
  </aside>
  
  <aside>
    
  ✅ 랭킹 정보 확인
  
  > 주황색 강조색으로 내 순위 확인 가능
  > 
  </aside>
    
</details>

<details>
  
<summary>🗂️ 보관함</summary>
    
  
![0_보관함](https://github.com/BYEOL-GOM/FP-FRONT/assets/157693710/980e5338-a392-4281-910d-26a71ee97338)

<aside>
  
💡 메인의 보관함 탭 클릭 

</aside>
  
  <aside>
    
  👆 조회하고 싶은 로켓 혹은 나에게 온 로켓 내역 클릭
  
  </aside>
  
  <aside>
    
  ✅ 로켓의 상세 정보 확인
  
  > 답례 여부, 답장 여부, 삭제 여부 확인 가능
  > 
  </aside>
    
</details>

<details>
  
<summary>📝 닉네임, 테마 변경</summary>
    
 ![0_테마변경](https://github.com/BYEOL-GOM/FP-FRONT/assets/157693710/065cf1ab-fb05-4e09-8c08-68cd8522f9e5)
  
  <aside>
    
  💡 메인에서 설정탭 클릭
  
  </aside>
  
  <aside>
    
  👆 닉네임 변경이라면 닉네임 탭 클릭
  
  </aside>
  
  <aside>
    
  🌟 모드 변경이라면 테마변경 토글 클릭
  
  </aside>
  
  <aside>
    
  ✅ 닉네임 혹은 테마변경 완료!
  
  </aside>
    
</details>


---

## **💻** 기술적 의사결정 (FE | BE)

<details>
  
<summary>기술적 의사결정(FE)</summary>
    
  | 사용 기술 | 채택 이유 |
  | --- | --- |
  | Vite | - CRA보다 빠른 빌드를 위해 채택 |
  | TypeScript | - 정적 타이핑 언어로 개발 프로세스 초기에 오류를 포착하여 코드 안전성에 도움이 됨 <br/> - 데이터 구조와 인터페이스를 명확하게 정의하여 가독성 향상<br/> - 코드의 유지, 관리가 용이 |
  | Zustand | - 허들이 낮아 쉽게 사용이 가능함<br/>- redux devtools를 사용할 수 있어 디버깅에 용이<br/>- 특정 라이브러리에 엮이지 않음 |  
  | React-Query (Tanstack-Query) | - data fetching, caching, server state 등을 활용하여 핵심 로직에 집중이 가능<br/>- API 호출을 여러 번 하지 않도록 만들어 주어, 코드의 효율성 증가 |
  | Axios | - 자바스크립트의 fetch에 비해 지원하는 기능이 다양함<br/> - response timeout 처리 방법이 존재하는 등 장점이 많음 |
  | Styled-component | - 유니크한 이름으로 CSS 설정을 가능하게 해 줌<br/> - 중복되는 class 관리에 용이, 컴포넌트는 재사용성이 증가 |
  | React-router-dom | - SPA 방식의 React 환경에서 페이지를 나눠 줌 |
  | Eslint / Prettier  -  @typescript | - 코드 컨벤션을 일정한 기준에 맞추어 작성할 수 있도록 스타일을 지정<br/> - 코드의 퀄리티가 보장됨 |
  | lodash | - throttle(쓰로틀)과 debounce(디바운스)와 같은 함수를 제공 |
  | three.js | - UI상의 3D 효과를 표현하기 위해 사용 |

</details>

<details>
  
<summary>기술적 의사결정(BE)</summary>
    
  | 사용 기술 | 채택 이유 |
  | --- | --- |
  | Social Login
  (카카오, 네이버) | - 사용자의 정보 노출을 최소화 <br/> - 무분별한 계정 가입을 방지 |
  | MySQL & Prisma | - MySQL은 안정성과 성능이 뛰어남<br/> - prisma ORM을 조합하여 DB 상호작용을 단순화 + 보안 강화 |
  | GitHub Actions | - GitHub 통합이 용이<br/> - 빠른 배포가 가능함 |
  | Winston | - 서버가 종료되면 쌓여있던 로그가 삭제되는 이슈 해결<br/> - 로그를 외부 파일에 저장해서 관리하기 위해 사용 |
  | Docker | - 팀원 및 서버와 개발 환경을 쉽게 동기화할 수 있음 |
  | PM2 | - 간단한 설정으로 무중단 배포 구현이 가능 |
  | Sentry | - 실시간 오류 모니터링을 통해 빠른 대응이 가능 |
  | WebSocket | - WebSocket 프로토콜은 정보를 동시에 송수신할 수 있어서 전이중 양방향 통신이 가능<br/> - 정보 교환이 빨라 지속적으로 업데이트 되는 정보를 수신해야 하는 채팅 기능에 적합 |
  | prettier | - 코드 컨벤션을 일정한 기준에 맞추어 작성할 수 있도록 스타일을 지정<br/> - 코드의 퀄리티가 보장됨 |

</details>

---

## **🧨 Trouble Shooting**


> FE
> 
<details>

<summary>🔍 보관함 탭 *이동 시마다* 불필요한 요청</summary>
    
  **문제점**
  
  - 보관함 탭 클릭 시 반복 요청.. 불필요한 요청이라 생각함.
  
  **원인**
  
  - 탭 클릭 시마다 api를 요청하게 되어있음
  
  **해결**
  
  - 무한 스크롤 부분을 tanstack-query를 이용해 탭마다 쿼리키를 지정,
  - staleTime과 gcTime을 설정해 데이터를 일정 시간 유지할 수 있도록 함
  - 데이터의 변경이 있을 경우 쿼리 무효화를 통해 불러올 수 있도록 변경
  
  ```jsx
    const {
      data: pastContent,
      fetchNextPage,
      hasNextPage,
      isPending,
    } = useInfiniteQuery({
      queryKey: ['worries', whoseContent],
      queryFn: ({ pageParam = 1 }) => getPastContent(pageParam),
      initialPageParam: 1,
      getNextPageParam: (lastPage) => {
        if (lastPage.result.length === 0) {
          return undefined;
        }
        return lastPage.isLast ? undefined : lastPage.nextPage;
      },
      retry: 1,
      staleTime: 1000 * 60,
      gcTime: 1000 * 60,
    });
  ```

</details>

<details>
  
<summary>♾ 무한 스크롤 시 요청 간격이 너무 빠름.</summary>
    
  **문제점**
  
  - 무한 스크롤에서 휠을 빠르게 내릴 경우 짧은 시간 내에 많은 요청이 발생
  - 너무 빠르다는 생각이 들어서 제한을 두어야 함
  
  **원인**
  
  - 무한 스크롤을 구현한 부분에서 IntersectionObserver의
  - *인뷰* div = ref가 빠르게 지속적으로 닿을 때마다 요청
  
  **해결**
  
  - 시간적인 제한을 걸어두면 어떨까 생각.
  - Throttle, Debounce 기법을 찾았고
  - ,Throttle => 일정 시간 동안 요청이 한 번만 수행되도록.
  - Debounce => 요청이 들어오고 일정 시간을 기다린 후 요청을 수행
  - Throttle 기법을 선택.
  - 이를 편하게 사용할 수 있는 lodash 라이브러리를 채택함.
      
      ```jsx
      import _ from 'lodash';
        const handleLoadMore = useMemo(
          () =>
            _.throttle(() => {
              if (hasNextPage) {
                fetchNextPage();
              }
            }, 500),
          [hasNextPage, fetchNextPage],
        );
      ```
        
</details>

<details>
  
<summary>👤 닉네임 변경 후 RankingBoard에 적용이 안됨.</summary>
    
  **문제점**
  
  - 닉네임을 변경하고 랭킹을 확인했을 때 바로 적용이 안 됨
  
  **원인**
  
  - RankingBoard의 query 설정에 staleTime이 20초로 설정되어 있었음
  
  **해결**
  
  - 닉네임이 변경되는 상태를 query로 관리
  - 닉네임 변경 쿼리가 실행될때 invalidateQueries로 랭킹보드의 query를 무효화
  
  ```jsx
  // 닉네임 변경 query
    const { data: currentNickname, isLoading: isFetchingNickname } = useQuery({
      queryKey: ['currentNickname'],
      queryFn: getUserName,
    });
    
    
  // 닉네임 변경 시 ranking query 무효화
      mutation.mutate(nickname, {
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['rankings'] });
          openStateModal('닉네임이 성공적으로 변경되었어요!');
          navigate('/mypage');
        },
      });
    };
  ```
    
</details>

<details>
  
<summary> 💬 실시간 채팅 기능 구현 </summary>
    
  **문제점**
  
  - socket을 사용해 이전 채팅 내용을 가져올 많은 로딩 시간 소요 및 중복 채팅 노출
  
  **원인**
  
  - socket.on을 통해 가져온 데이터들이 한 번에 전송되어 로딩 발생 & 룸접속 유저에게 
  모두 보여지는 것이 원인. 그래서 API를 통해 이전 내용은 서버로부터 직접 전달받았으나,
  socket의 실시간 채팅과 겹쳐버리는 문제가 새롭게 발생
  
  **해결**
  
  - 기존 내역 메세지 + socket.on으로 전달받은 메세지를 통합 후, 
  chatId를 바탕으로 중복 메세지를 제거하고 업데이트 되는 방향으로 수정
  
  ```jsx
  useEffect(() => {
      if (chatMessages) {
        const formattedPastMessages = chatMessages.pages.flatMap(
          (page) => page.formattedPastMessages,
        );
        setRoomMessages((prevMessages) => {
          const uniqueMessages = formattedPastMessages.filter((msg) =>
            prevMessages.every((prevMsg) => prevMsg.chatId !== msg.chatId),
          );
          return [...prevMessages, ...uniqueMessages];
        });
      }
    }, [chatMessages]);
  ```
 </details>


> BE

<details>

<summary>👀 네이버 로그인 요청시 타 유저의 계정으로 로그인됨</summary>
    
  **문제점**
  
  - 네이버 로그인을 시도하면 본인의 계정이 아닌 다른 사람의 계정으로 로그인됨
  
  **원인**
  
  - 로그인에 필요한 유저 정보를 받아오는 과정에서 고유 회원 번호를 잘못 할당하는 것이 원인.
  
  **해결**
  
  - 유저 테이블에 유저 회원번호를 체크하는 칼럼을 추가하여 해당유저의 정보가 있는지 없는지 판단하여 유저정보가 없으면 유저정보를 생성하고 유저정보가 있으면 바로 토큰 발급
  
  ```jsx
  
          const findUser = await prisma.users.findFirst({
              where: { userCheckId: user.id.toString() },
          });
  
          if (!findUser) {
              const lastUser = await prisma.users.count();
              const createUser = await prisma.users.create({
                  data: {
                      userCheckId: user.id.toString(),
                      nickname: `고민의 늪에 빠진 곰 ${lastUser + 1}`,
                      email: user.email,
                  },
              });
  
  ```
    
 </details>

<details>
  
<summary>💬 답장이 오지 않는 경우 고민 또는 메세지 작성이 불가함</summary>
  
  **문제점**
  
  - 고민 로켓을 모두 소진했는데 어떠한 답장도 오지 않을 경우 사용자는 더 이상 메세지를 작성할 수 없음
  
  **원인**
  
  - 고민 로켓 회복은 답례를 받거나, 내가 보낸 고민이 상대방에 의해 삭제 되었을 경우에만 가능
  - 답변이 없는 상황에 고민 로켓이 회복되는 조건 부재
  
  **해결**
  
  - node-cron 라이브러리를 사용하여 마지막 대화 기준 12시간 이상 답장 메세지가 오지 않으면 매일 밤 자정 12시에 해당 메세지가 소프트 삭제되고 고민 작성 로켓과 답변 작성 카운트 수가 회복되는 것으로 해결
  
  ```jsx
  // 매일 자정에 스케줄러 실행
  cron.schedule('0 0 * * *', async () => {
      console.log('매일 자정에 오래된 고민 삭제 작업을 시작합니다.');
      try {
          await deleteOldMessages();
          console.log('오래된 고민 삭제 작업이 성공적으로 완료되었습니다.');
      } catch (error) {
          console.error('오래된 고민 삭제 작업 중 오류가 발생했습니다:', error);
      }
  });
  
  // # 생성된후 12시간 동안 답변이 없는 고민 or 12시간동안 답장이 오지 않는 메세지 조회
  export const findOldMessages = async (prismaClient) => {
      const twentyFourHoursAgo = new Date(new Date().getTime() - 12 * 60 * 60 * 1000);
  
      return await prismaClient.worries.findMany({
          where: {
              OR: [
                  {
                      // 답변이 없고 createdAt이 12시간 이상된 경우
                      createdAt: { lt: twentyFourHoursAgo },
                      comments: { none: {} },
                  },
                  {
                      // 답변이 있고 updatedAt이 12시간 이상된 경우
                      updatedAt: { lt: twentyFourHoursAgo },
                      comments: { some: {} },
                  },
              ],
              deletedAt: null,
          },
          select: { worryId: true },
      });
  };
  
  // # worryId에 해당하는 comments 모두 소프트 삭제
  export const deleteAllCommentsForWorry = async (worryId, prismaClient) => {
      await prismaClient.comments.updateMany({
          where: { worryId },
          data: { deletedAt: new Date() },
      });
  };
  
  // # worryId에 해당하는 고민 메세지 삭제
  export const deleteSelectedWorry = async (worryId, prismaClient) => {
      await prismaClient.worries.updateMany({
          where: { worryId },
          data: { deletedAt: new Date() },
      });
  };
  
  // # 사용자 카운트 업데이트
  export const updateUserCounts = async (worryAuthorId, commentAuthorId, prismaClient) => {
      // 고민 작성자의 remainingWorries 증가
      await prismaClient.users.updateMany({
          where: { userId: worryAuthorId, remainingWorries: { lt: 5 } },
          data: { remainingWorries: { increment: 1 } },
      });
      // 답변 작성자의 remainigAnswers 증가
      await prismaClient.users.updateMany({
          where: { userId: commentAuthorId, remainingAnswers: { lt: 5 } },
          data: { remainingAnswers: { increment: 1 } },
      });
  };
  ```
    
</details>

<details>
<summary>🤬 금지어 필터링시 데이터 베이스 성능 우려</summary>
    
  **문제점**
  
  - 고민/답장 메세지 작성 API 호출시 금지어 필터링 검사를 위해 데이터베이스 접근을 매번 해야함
  
  **원인**
  
  - 금지어 키워드를 데이터베이스에 저장해두고 글 작성시 필터링함
  
  **해결**
  
  - 서버 시작 시 금지어 목록을 메모리에 로드함으로써 매번 데이터 베이스에 직접 접근하지 않아 성능 우려를 최소화함
  
  ```jsx
   
  global.bannedWords = [];
  
  // 금지어 목록 로드
  export async function loadBannedWords() {
      const bannedWords = await prisma.bannedWords.findMany({
          select: { word: true },
      });
      global.bannedWords = bannedWords.map((wordObj) => wordObj.word);
  }
      
      
      loadBannedWords()
      .then(() => {
          console.log('금지어 목록이 메모리에 로드되었습니다.');
      })
      .catch((error) => {
          console.error('금지어 목록 로딩 중 오류 발생:', error);
      });
      
      
      
   // 글작성 API 요청시 금지어 포함 여부 확인
          const isBannedWordIncluded = global.bannedWords.some((word) => content.includes(word));
  
          if (isBannedWordIncluded) {
              throw new AppError('금지어가 포함된 내용은 등록할 수 없습니다', 400);
          }
  ```

</details>    

> 유저 피드백

<details>

<summary>💬 콘텐츠가 없다.</summary>
    
  **문제점**
  
  - 사용 유저 수가 적기에 처음 사용자가 접속했을 경우 할 게 너무 없음…
  
  **원인**
  
  - 보관함의 경우 처음 기획의도는 답례를 주고받은 경우만 표시,
  - 로켓을 보낸 후 확인할 방법이 전혀 없음.
  
  **해결**
  
  - 보낸 메시지 받은 메시지 모두 보여줌.
  - 답변이 삭제되었다면 삭제 표시, 답례를 받았다면 받은 표시
  - 답례를 받아 구매할 수 있는 행성 상점 구현
  - 랜덤 한 유저와 로켓을 주고받는 중 *1 대 1* 대화로 이어질 수 있도록 *채팅 기능* 구현

 </details>

<details>
<summary>💬 너무 느리다</summary>
    
  **문제점**
  
  - 사이트 속도가 너무 느리다… 답답함
  
  **원인**
  
  - s3 배포를 처음 도전했으나, 국가를 유럽으로 설정해버림
  
  **해결**
  
  - 국가 한국으로 이동, 및 도메인 구매 후 적용 완료.

</details>

---

# 🏅 수상 이력


![디자인상_별곰](https://github.com/BYEOL-GOM/FP-FRONT/assets/155723499/81db5958-8a46-4494-b13d-ce227bff0ca8)
![팀워크기여_김준오](https://github.com/coco-camel/byeolgom/assets/157693710/2257aa21-8401-419a-8a33-0fb8e96a4c14)

